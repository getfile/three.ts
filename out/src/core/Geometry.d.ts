import { BufferGeometry } from "./BufferGeometry";
import { EventDispatcher } from './EventDispatcher';
import { Face3 } from './Face3';
import { Sphere } from '../geom/Sphere';
import { Box3 } from '../geom/Box3';
import { Vector3 } from '../math/Vector3';
import { Color } from '../math/Color';
declare class Geometry extends EventDispatcher {
    vertices: Vector3[];
    colors: Color[];
    faces: Face3[];
    faceVertexUvs: any;
    morphTargets: any;
    morphNormals: any;
    skinWeights: any;
    skinIndices: any;
    lineDistances: number[];
    boundingBox: Box3;
    boundingSphere: Sphere;
    elementsNeedUpdate: boolean;
    verticesNeedUpdate: boolean;
    uvsNeedUpdate: boolean;
    normalsNeedUpdate: boolean;
    colorsNeedUpdate: boolean;
    lineDistancesNeedUpdate: boolean;
    groupsNeedUpdate: boolean;
    parameters: any;
    constructor();
    applyMatrix(matrix: any): this;
    rotateX(angle: number): this;
    rotateY(angle: number): this;
    rotateZ(angle: number): this;
    translate(x: number, y: number, z: number): this;
    scale(x: number, y: number, z: number): this;
    lookAt(vector: Vector3): void;
    fromBufferGeometry(geometry: BufferGeometry): this;
    center(): Vector3;
    normalize(): this;
    computeFaceNormals(): void;
    computeVertexNormals(areaWeighted?: boolean): void;
    computeFlatVertexNormals(): void;
    computeMorphNormals(): void;
    computeLineDistances(): void;
    computeBoundingBox(): void;
    computeBoundingSphere(): void;
    merge(geometry: any, matrix: any, materialIndexOffset?: number): void;
    mergeMesh(mesh: any): void;
    mergeVertices(): number;
    setFromPoints(points: any): this;
    sortFacesByMaterialIndex(): void;
    toJSON(): any;
    clone(): Geometry;
    copy(source: Geometry): Geometry;
    dispose(): void;
}
export { Geometry };
