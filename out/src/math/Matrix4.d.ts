import { Vector3 } from './Vector3';
import { Quaternion } from "./Quaternion";
import { Euler } from "./Euler";
import { BufferAttribute } from "../core/BufferAttribute";
declare class Matrix4 {
    elements: Array<number>;
    constructor();
    set(n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number): Matrix4;
    identity(): Matrix4;
    clone(): Matrix4;
    copy(m: Matrix4): Matrix4;
    copyPosition(m: Matrix4): Matrix4;
    extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4;
    makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): this;
    extractRotation(m: Matrix4): this;
    makeRotationFromEuler(euler: Euler): this;
    makeRotationFromQuaternion(q: Quaternion): this;
    lookAt(eye: Vector3, target: Vector3, up: Vector3): this;
    multiply(m: Matrix4, n: Matrix4): this;
    premultiply(m: Matrix4): this;
    multiplyMatrices(a: Matrix4, b: Matrix4): this;
    multiplyScalar(s: number): this;
    applyToBufferAttribute(attribute: BufferAttribute): BufferAttribute;
    determinant(): number;
    transpose(): this;
    setPosition(v: Vector3): this;
    getInverse(m: Matrix4, throwOnDegenerate?: boolean): Matrix4;
    scale(v: Vector3): this;
    getMaxScaleOnAxis(): number;
    makeTranslation(x: number, y: number, z: number): this;
    makeRotationX(theta: number): this;
    makeRotationY(theta: number): this;
    makeRotationZ(theta: number): this;
    makeRotationAxis(axis: Vector3, angle: number): this;
    makeScale(x: number, y: number, z: number): this;
    makeShear(x: number, y: number, z: number): this;
    compose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
    decompose(position: Vector3, quaternion: Quaternion, scale: Vector3): this;
    makePerspective(left: number, right: number, top: number, bottom: number, near: number, far: number): this;
    makeOrthographic(left: number, right: number, top: number, bottom: number, near: number, far: number): this;
    equals(matrix: Matrix4): boolean;
    fromArray(array: Array<number>, offset?: number): this;
    toArray(array?: Array<number>, offset?: number): number[];
}
export { Matrix4 };
